# -*- coding: utf-8 -*-
"""Digital_Wallet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EhRp8tP75vKomF8rOQdmi4k9PqlB35ZI
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

# Configuration
USER_DATA = 'users.csv'
COLUMNS = ['username', 'password', 'email', 'mobile', 'balance', 'transactions']
BILL_COLORS = {
    'Electricity': '#FF6B6B',
    'Gas': '#4ECDC4',
    'Internet': '#45B7D1',
    'Mobile': '#96CEB4',
    'Transfers': '#D4A5A5'
}

# Custom CSS with dark mode support
st.markdown("""
<style>
    .txn-card {
        padding: 1rem;
        margin: 0.5rem 0;
        border-radius: 10px;
        background: var(--background-color);
        border-left: 4px solid;
        transition: transform 0.2s;
    }
    .txn-card:hover {
        transform: translateX(5px);
    }
    .txn-in { border-color: #4CAF50; }
    .txn-out { border-color: #F44336; }
    .txn-bill { border-color: #FFC107; }
    .amount-in { color: #4CAF50; }
    .amount-out { color: #F44336; }
    .chart-container {
        background: var(--background-color);
        padding: 1rem;
        border-radius: 10px;
    }
</style>
""", unsafe_allow_html=True)

def load_users():
    try:
        users_df = pd.read_csv(USER_DATA).astype({'mobile': str})
        # Clean transaction data on load
        users_df['transactions'] = users_df['transactions'].fillna('')
        users_df['mobile'] = users_df['mobile'].astype(str)
        return users_df
    except FileNotFoundError:
        return pd.DataFrame(columns=COLUMNS)

def save_users(df):
    df.to_csv(USER_DATA, index=False)

def auth_pages():
    st.markdown("<h1 style='text-align: center; color: #6366f1;'>üè¶ Digital Wallet</h1>", unsafe_allow_html=True)
    st.markdown("<h3 style='text-align: center; margin-bottom: 2rem;'>Welcome to Pakistan's Modern Banking Solution</h3>", unsafe_allow_html=True)

    col1, col2 = st.columns([1, 1], gap="large")

    with col1:
        with st.container():
            st.markdown("<h2 style='text-align: center;'>üîë Login</h2>", unsafe_allow_html=True)
            with st.form("login_form"):
                username = st.text_input("Username", key="login_user")
                password = st.text_input("Password", type="password", key="login_pass")
                submitted = st.form_submit_button("Login ‚Üí", use_container_width=True)

                if submitted:
                    users_df = load_users()
                    user = users_df[(users_df['username'] == username) & (users_df['password'] == password)]
                    if not user.empty:
                        st.session_state['user'] = user.iloc[0].to_dict()
                        st.rerun()
                    else:
                        st.markdown("<div class='error-message'>‚ö†Ô∏è Invalid username or password</div>", unsafe_allow_html=True)

    with col2:
        with st.container():
            st.markdown("<h2 style='text-align: center;'>üìù Sign Up</h2>", unsafe_allow_html=True)
            with st.form("signup_form"):
              email = st.text_input("Email")
              mobile = st.text_input("Mobile Number (e.g., 03XXYYYYYYY)")
              username = st.text_input("Username")
              password = st.text_input("Password", type="password")
              submitted = st.form_submit_button("Create Account ‚Üí")
              
              if submitted:
                  users_df = load_users()
                  # Normalize mobile number before checking duplicates
                  mobile = normalize_mobile(mobile)
                  
                  if any([not email, not mobile, not username, not password]):
                      st.error("All fields are required!")
                      return
                  
                  # Check duplicates using original columns with normalization
                  mobile_exists = users_df['mobile'].apply(normalize_mobile).eq(mobile).any()
                  email_exists = users_df['email'].eq(email).any()
                  username_exists = users_df['username'].eq(username).any()
                  
                  if any([email_exists, mobile_exists, username_exists]):
                      st.error("Email, mobile, or username already exists!")
                      return
                        
                  new_user = pd.DataFrame([{
                      'username': username,
                      'password': password,
                      'email': email,
                      'mobile': mobile,  # Store normalized number
                      'balance': 0.0,
                      'transactions': ''
                  }])
                  
                  users_df = pd.concat([users_df, new_user], ignore_index=True)
                  save_users(users_df)
                  st.markdown("<div class='success-message'>üéâ Account created successfully! Please login</div>", unsafe_allow_html=True)

# mobile number normalization function
def normalize_mobile(number):
    """Convert any Pakistani mobile format to standard 03XXYYYYYYY"""
    num = str(number).strip()
    if num.startswith('+92'):
        return '0' + num[3:]  # +92345... ‚Üí 0345...
    elif num.startswith('92'):
        return '0' + num[2:]   # 92345... ‚Üí 0345...
    elif num.startswith('0') and len(num) == 11:
        return num             # Already in correct format
    elif len(num) == 10:
        return '0' + num       # 345... ‚Üí 0345...
    return num  # Return original if not a mobile number


def transaction_window():
    st.markdown("### üìú Transaction History")
    user = st.session_state['user']

    # Safely handle transaction data
    transactions = []
    raw_txns = user.get('transactions', '')

    # Convert to string and handle NaN/None cases
    txns_str = str(raw_txns) if pd.notna(raw_txns) else ''

    # Clean and split transactions
    if txns_str.strip() not in ['', 'nan']:
        for txn in txns_str.split(';'):
            txn = txn.strip()
            if txn and txn != 'nan':  # Skip empty and NaN strings
                parts = txn.split(',')
                if len(parts) >= 4:
                    try:
                        transactions.append({
                            'date': parts[0],
                            'type': parts[1],
                            'amount': float(parts[2]),
                            'party': parts[3],
                            'original': txn
                        })
                    except ValueError:
                        continue  # Skip malformed transactions

        # Filter options
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            show_in = st.checkbox("Received", True)
        with col2:
            show_out = st.checkbox("Sent", True)
        with col3:
            show_bills = st.checkbox("Bills", True)
        with col4:
            show_deposits = st.checkbox("Deposits", True)

        # Display transactions
        for txn in reversed(transactions):
            txn_type = txn['type']
            amount = txn['amount']
            is_bill = 'bill_' in txn_type

            # Handle deposits first
            if txn_type == 'deposit' and show_deposits:
                cls = 'txn-in'
                emoji = 'üíµ'
                verb = 'Deposit'
                amount_cls = 'amount-in'
                sign = '+'
                party = 'System'
                is_bill = False
            else:
                # Handle other transaction types
                if txn_type == 'receive' and show_in:
                    cls = 'txn-in'
                    emoji = 'üì•'
                    verb = 'Received from'
                    amount_cls = 'amount-in'
                    sign = '+'
                elif (txn_type == 'send' and show_out) or (is_bill and show_bills):
                    cls = 'txn-out' if txn_type == 'send' else 'txn-bill'
                    emoji = 'üì§' if txn_type == 'send' else 'üßæ'
                    verb = 'Sent to' if txn_type == 'send' else 'Paid to'
                    amount_cls = 'amount-out'
                    sign = '-'
                else:
                    continue  # Skip hidden transactions

                party = txn['party']
                if is_bill:
                    bill_type = txn_type.split('_')[1].capitalize()
                    verb = f"{bill_type} Payment"

            # Render transaction card
            st.markdown(f"""
            <div class="txn-card {cls}">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div style="flex: 2;">
                        {emoji} <strong>{verb}</strong><br>
                        <small style="opacity: 0.8;">{txn['date']}</small>
                    </div>
                    <div style="flex: 1; text-align: right;">
                        <span class="{amount_cls}"><strong>{sign}‚Ç®{amount:,.2f}</strong></span><br>
                        <small style="opacity: 0.8;">{party}</small>
                    </div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.info("No transactions yet")

def financial_analytics():
    st.markdown("### üìä Financial Analytics")
    user = st.session_state['user']

    if user['transactions']:
        expenses = []
        income = []

        for txn in user['transactions'].split(';'):
            parts = txn.split(',')
            if len(parts) >= 4:
                txn_type = parts[1]
                amount = float(parts[2])
                party = parts[3]

                # Track all expenses (both transfers and bills)
                if txn_type in ['send', 'bill_electricity', 'bill_gas',
                               'bill_internet', 'bill_mobile']:
                    if 'bill_' in txn_type:
                        category = txn_type.split('_')[1].capitalize()
                    else:
                        category = 'Transfers'
                    expenses.append({'Category': category, 'Amount': amount})

                # Track income
                elif txn_type in ['receive', 'deposit']:
                    income.append({'Category': 'Deposit' if txn_type == 'deposit' else 'Received',
                                 'Amount': amount})

        # Create tabs
        tab1, tab2 = st.tabs(["Expenses", "Income"])

        with tab1:
            if expenses:
                df = pd.DataFrame(expenses)
                df = df.groupby('Category').sum().reset_index()
                create_expense_chart(df)
            else:
                st.info("No expenses to show")

        with tab2:
            if income:
                df = pd.DataFrame(income)
                df = df.groupby('Category').sum().reset_index()
                create_income_chart(df)
            else:
                st.info("No income to show")
    else:
        st.info("No transactions to analyze")

def create_expense_chart(df):
    # Determine theme colors
    is_dark = st._config.get_option("theme.base") == "dark"
    text_color = 'white' if is_dark else 'black'
    bg_color = 'none'  # Transparent background

    # Generate colors based on categories
    colors = [BILL_COLORS.get(cat, BILL_COLORS['Transfers']) for cat in df['Category']]

    fig, ax = plt.subplots(figsize=(8, 6), facecolor=bg_color)
    wedges, texts, autotexts = ax.pie(
        df['Amount'],
        labels=df['Category'],
        colors=colors,
        autopct=lambda p: f'‚Ç®{p*sum(df["Amount"])/100:,.0f}\n({p:.1f}%)',
        startangle=90,
        textprops={'color': text_color}
    )

    plt.setp(autotexts, size=8, weight="bold")
    ax.set_title("Expense Breakdown", color=text_color)

    # Create legend with proper color adaptation
    legend_labels = [f"{row['Category']} (‚Ç®{row['Amount']:,.0f})" for _, row in df.iterrows()]
    legend = ax.legend(
        wedges,
        legend_labels,
        title="Categories",
        loc="center left",
        bbox_to_anchor=(1, 0.5),
        labelcolor=text_color  # Use actual color value here
    )

    # Set legend title color
    plt.setp(legend.get_title(), color=text_color)

    st.pyplot(fig)

def create_income_chart(df):
    # Determine theme colors
    is_dark = st._config.get_option("theme.base") == "dark"
    text_color = 'white' if is_dark else 'black'
    bg_color = 'none'  # Transparent background

    # Define income colors
    income_colors = ['#4CAF50', '#45B7D1', '#81C784']

    fig, ax = plt.subplots(figsize=(8, 6), facecolor=bg_color)
    wedges, texts, autotexts = ax.pie(
        df['Amount'],
        labels=df['Category'],
        autopct=lambda p: f'‚Ç®{p*sum(df["Amount"])/100:,.0f}\n({p:.1f}%)',
        startangle=90,
        colors=income_colors[:len(df)],  # Use first n colors from palette
        textprops={'color': text_color}
    )

    plt.setp(autotexts, size=8, weight="bold")
    ax.set_title("Income Breakdown", color=text_color)

    # Create legend with proper color adaptation
    legend_labels = [f"{row['Category']} (‚Ç®{row['Amount']:,.0f})" for _, row in df.iterrows()]
    legend = ax.legend(
        wedges,
        legend_labels,
        title="Sources",
        loc="center left",
        bbox_to_anchor=(1, 0.5),
        labelcolor=text_color
    )

    # Set legend title color
    plt.setp(legend.get_title(), color=text_color)

    st.pyplot(fig)

def dashboard():
    user = st.session_state['user']

    # Notification System
    if 'last_transaction' in st.session_state:
        txn = st.session_state.last_transaction
        emoji = "üí∏" if txn['type'] == 'send' else "üì•" if txn['type'] == 'receive' else "üßæ"
        st.markdown(f"""
        <div class='success-message'>
            {emoji} {txn['message']}
        </div>
        """, unsafe_allow_html=True)
        del st.session_state.last_transaction

    # Dashboard Header
    col1, col2 = st.columns([4, 1])
    with col1:
        st.markdown(f"<h1 style='color: var(--text-color);'>üè¶ Welcome, {user['username']}</h1>",
                    unsafe_allow_html=True)
    with col2:
        if st.button("üö™ Logout", use_container_width=True):
            del st.session_state['user']
            st.rerun()

    # Balance Card
    st.markdown(f"""
    <div class='auth-card' style='background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white;'>
        <h3>Available Balance</h3>
        <h1>‚Ç® {user['balance']:,.2f}</h1>
    </div>
    """, unsafe_allow_html=True)

    # Quick Actions
    st.markdown("---")
    cols = st.columns(4)
    with cols[0]:
        if st.button("üì• Add Funds", use_container_width=True):
            st.session_state['show_add_funds'] = True
    with cols[1]:
        if st.button("üì§ Send Money", use_container_width=True):
            st.session_state['show_send_money'] = True
    with cols[2]:
        if st.button("üßæ Pay Bills", use_container_width=True):
            st.session_state['show_pay_bills'] = True
    with cols[3]:
        if st.button("üìä Analytics", use_container_width=True):
            st.session_state['show_analytics'] = True

    # In the Add Funds section of the dashboard function
    if st.session_state.get('show_add_funds'):
      with st.expander("üíµ Add Funds", expanded=True):
          with st.form("add_funds"):
              amount = st.number_input("Amount (PKR)", min_value=100.0, step=500.0)
              if st.form_submit_button("üí≥ Add Funds"):
                  users_df = load_users()
                  idx = users_df.index[users_df['username'] == user['username']][0]

                  # Update balance
                  users_df.at[idx, 'balance'] += amount

                  # Create transaction record
                  timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                  txn = f"{timestamp},deposit,{amount},System"

                  # Handle transaction history
                  current_txns = users_df.at[idx, 'transactions']
                  if pd.isna(current_txns) or str(current_txns).strip() == '':  # Enhanced check
                      users_df.at[idx, 'transactions'] = txn
                  else:
                      users_df.at[idx, 'transactions'] += ';' + txn

                  save_users(users_df)

                  # Update session state
                  st.session_state.last_transaction = {
                      'type': 'deposit',
                      'message': f"Added ‚Ç®{amount:,.2f} to your account"
                  }
                  st.session_state['user'] = users_df.iloc[idx].to_dict()
                  st.session_state['show_add_funds'] = False
                  st.rerun()

    # Send Money Section
    if st.session_state.get('show_send_money'):
      with st.expander("üì§ Send Money", expanded=True):
        with st.form("send_money"):
            recipient = st.text_input("Recipient's Email/Mobile")
            amount = st.number_input("Amount (PKR)", min_value=10.0, step=100.0)
            note = st.text_input("Add Note (Optional)")
            if st.form_submit_button("üí∏ Send Now"):
                users_df = load_users()
                
                # Normalize input and existing mobile numbers
                normalized_recipient = normalize_mobile(recipient)
                users_df['mobile'] = users_df['mobile'].apply(normalize_mobile)
                
                # Find recipient using normalized numbers
                recipient_user = users_df[
                    (users_df['email'] == normalized_recipient) | 
                    (users_df['mobile'] == normalized_recipient)
                ]

                if recipient_user.empty:
                    st.error("Recipient not found")
                else:
                    sender_idx = users_df.index[users_df['username'] == user['username']][0]
                    if users_df.at[sender_idx, 'balance'] < amount:
                        st.error("Insufficient balance")
                    else:
                        # Update balances
                        users_df.at[sender_idx, 'balance'] -= amount
                        recipient_idx = recipient_user.index[0]
                        users_df.at[recipient_idx, 'balance'] += amount

                        # Record transactions
                        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        sender_txn = f"{timestamp},send,{amount},{recipient_user.iloc[0]['username']} ({note})"
                        receiver_txn = f"{timestamp},receive,{amount},{user['username']} ({note})"

                        # Handle empty transactions
                        users_df.at[sender_idx, 'transactions'] = (
                            f"{users_df.at[sender_idx, 'transactions']};{sender_txn}"
                            if pd.notna(users_df.at[sender_idx, 'transactions'])
                            else sender_txn
                        )

                        users_df.at[recipient_idx, 'transactions'] = (
                            f"{users_df.at[recipient_idx, 'transactions']};{receiver_txn}"
                            if pd.notna(users_df.at[recipient_idx, 'transactions'])
                            else receiver_txn
                        )

                        save_users(users_df)
                        st.session_state.last_transaction = {
                            'type': 'send',
                            'message': f"Sent ‚Ç®{amount:,.2f} to {recipient_user.iloc[0]['username']}"
                        }
                        st.session_state['user'] = users_df.iloc[sender_idx].to_dict()
                        st.session_state['show_send_money'] = False
                        st.rerun()

    # Bill Payments Section
    if st.session_state.get('show_pay_bills'):
        with st.expander("üßæ Pay Bills", expanded=True):
            service = st.selectbox("Select Service", [
                "Electricity", "Gas", "Internet", "Mobile"
            ])

            if service == "Electricity":
                with st.form("electricity_bill"):
                    provider = st.selectbox("Provider", ["IESCO", "LESCO", "K-Electric"])
                    ref_no = st.text_input("Consumer Number")
                    amount = st.number_input("Amount", min_value=100.0)
                    if st.form_submit_button("‚ö° Pay Bill"):
                        process_bill_payment("Electricity", provider, ref_no, amount)

            elif service == "Gas":
                with st.form("gas_bill"):
                    provider = st.selectbox("Provider", ["SNGPL", "SSGC"])
                    ref_no = st.text_input("Consumer Number")
                    amount = st.number_input("Amount", min_value=100.0)
                    if st.form_submit_button("üî• Pay Bill"):
                        process_bill_payment("Gas", provider, ref_no, amount)

            elif service == "Internet":
                with st.form("internet_bill"):
                    provider = st.selectbox("Provider", ["PTCL", "Nayatel", "Storm Fiber"])
                    ref_no = st.text_input("Account Number")
                    amount = st.number_input("Amount", min_value=500.0)
                    if st.form_submit_button("üåê Pay Bill"):
                        process_bill_payment("Internet", provider, ref_no, amount)

            elif service == "Mobile":
                with st.form("mobile_bill"):
                    provider = st.selectbox("Provider", ["Jazz", "Zong", "Telenor", "Ufone"])
                    number = st.text_input("Mobile Number")
                    amount = st.number_input("Amount", min_value=10.0)
                    if st.form_submit_button("üì± Recharge"):
                        process_bill_payment("Mobile", provider, number, amount)



    transaction_window()

    if st.session_state.get('show_analytics'):
      financial_analytics()

    # Responsive Layout for Mobile
    st.markdown("""
    <style>
        @media (max-width: 768px) {
            .col1, .col2 {
                width: 100% !important;
            }
        }
    </style>
    """, unsafe_allow_html=True)

def process_bill_payment(service, provider, ref_no, amount):
    users_df = load_users()
    user_idx = users_df.index[users_df['username'] == st.session_state['user']['username']][0]

    if users_df.at[user_idx, 'balance'] < amount:
        st.error("Insufficient balance")
        return

    users_df.at[user_idx, 'balance'] -= amount
    txn = f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')},bill_{service.lower()},{amount},{provider} ({ref_no})"
    users_df.at[user_idx, 'transactions'] = txn if pd.isna(users_df.at[user_idx, 'transactions']) else users_df.at[user_idx, 'transactions'] + ';' + txn
    save_users(users_df)

    st.session_state.last_transaction = {
        'type': 'bill',
        'message': f"Paid ‚Ç®{amount:,.2f} to {provider} ({service})"
    }
    st.session_state['user'] = users_df.iloc[user_idx].to_dict()
    st.session_state['show_pay_bills'] = False
    st.rerun()

def main():
    if 'user' not in st.session_state:
        auth_pages()
    else:
        dashboard()

if __name__ == "__main__":
    main()
